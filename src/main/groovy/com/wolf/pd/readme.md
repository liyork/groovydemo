groovy程序设计


语言就像能使我们在平台航行的交通工具，通过它可以轻松抵达该平台的各个部分。
寻找更为轻量级且搞笑的语言， 若使用得当，动态语言、函数式编程风格和元编程功能可以更快航行
groovy，轻量级，限制少，动态，面向对象，运行在jvm上
编译为java字节码，还扩充了javaapi和类库
部署时，常规java及组件还需要groovy的jar文件

动态语言能在运行时扩展程序，包括修改类型、行为和对象结构。静态语言在编译时做的事，利用动态语言，在运行时做。
动态语言的灵活性给我们带来在应用执行时演进程序的优势

通过仔细应用动态语言的功能，可以根据开发效率。在更短的时间内轻松创建更高层的抽象。
大部分动态语言是动态类型的， 类型基于对上下文的推断。

应该基于一系列标准选择语言：需求、偏好和北京，开发的项目以及公司的技术背景等

groovy让我们专注于完成工作，而不是将精力浪费在处理闹人的系统级细节上

方法和类默认public

按照特定约定暴露出其属性的java对象就被称为javabean

groovy是支持可选类型的动态类型语言

groovy编译器不会像java编译器那样执行类型检查。

只有当派生类是真正可替换的，而且可代替基类使用时，继承才显示出其优势。

动态类型语言中的类型是在运行时推断，方法及其参数也在运行时检查。可以再运行时向类中注入行为，从而使代码比严格的静态类型具有更好的可扩展性

编译时类型检查所提供的安全性让人产生了依赖。但是类型安全中的安全性和社会性保障中的保障同样让人放心。。

好的类型检查应该像一个好政府————只做必要的事，不能阻碍发展

在重复快速的“编辑-运行-测试”循环的同时，不必再对编译错误、运行时错误和测试失败作太多区分，关键在于让代码持续工作并让所有测试通过

动态类型可以再不知道方法具体细节时编写对象上的调用语句，运行期间，对象会动态地响应方法或消息。真正的多态不关注类型————把一个消息发送给一个对象，
运行时，他会确定所要使用的相应实现，而不是像静态语言的继承+多态。

动态类型语言，不会再代码编辑时或编译时执行类型检查，但是把一个对象当做错误的类型，goorby会在运行时提示出来。把实际的验证推迟到运行时，
得以在编码和编译时，以及在代码执行时修改程序的结果。

契约最好不要太过严格，要有一定的灵活性， 以便以可接受的方式满足或超出预期

若能使用时加以自律，能力式设计可以创建高度可扩展、简洁的代码，代码中的强制类型转换和噪音少一些，类层次结构也更短。

groovy是动态类型也是可选类型，是一门运行在jvm上的语言。即便是允许使用类型，但是也是强制转换，然后在运行时发现错误，仍然是动态类型

过早的优化是万恶之源

使用groovy编程时，倾向于省略类型，不过会为形参或变量选择表达性好的名字，在必要情况下也会指明类型
从使用的角度看，社区倾向于总是指明方法签名的类型，优势是在方法调用时知道实参的类型，同时避免了方法内不必要的运行时类型检查。

groovy中的闭包是去掉冗长匿名内部类的短小匿名方法，轻量级，短小、间接。
闭包是从函数式编程的lambda表达式派生而来。一个lambda表达式指定了一个函数的参数与映射。
闭包完全避免代码的冗长，可以辅助创建轻量级、可服用的代码片段。

闭包能扩充、优化或增强另一端代码。如，可以将选择对象的操作，通过一个谓词或条件提炼出来，而闭包对于表达这样的谓词或条件可能很有用。
也可以通过闭包来使用协成(Coroutine)，实现诸如迭代器或循环中的控制流转移

闭包有两个非常擅长的具体领域：
a.辅助资源清理
b.辅助创建内部的领域特定语言(DSL)

普通函数在实现某个目标明确的任务时优于闭包，重构的过程是引入闭包的好时机
闭包应该保持短小，有内聚性。应该设计为附到方法调用上的小段代码，只有几行。在调用方法时实现的闭包一定要非常简单，显而易见。


groovy通过便捷方法对JDK增强，其中很多方法大量使用闭包。这一扩展称为Groovy Java开发包(Groovy Java Development Kit,Groovy JDK)或GDK

GPath与XPath可以帮助导航XML文档的层次结构类似，GPath可以帮助导航对象(Plain Old Java Object和Plain Old Groovy Object)和XML的层次结构
用句点.符号遍历层次结构，

## 第9章，使用数据库
xxxxx


## 第10章，使用脚本和类


##第11章，探索元对象协议
基于应用的当前状态，或基于应用接受的输入，动态地添加方法和行为，代码会变得更为灵活，创造力和开发效率也提高，用groovy元编程

元编程(metaprogramming)是编写能够操作程序的程序
groovy动态语言通过元对象协议(MetaObject Protocol,MOP)，提供这种能力。

groovy对象是带有附加功能的java对象。groovy中，groovy对象比编译好的java对象具有更多的动态行为，在groovy对象上的方法调用和java也不同

一个groovy应用中，使用三类对象:POJO(Plain Old Java Object)、POGO(Plain Old Groovy Object)、Groovy拦截器
POGO是用Groovy编写的对象，扩展了java.lang.Object，也实现了groovy.lang.GroovyObject接口。
groovy拦截器是扩展了GroovyInterceptable的Groovy对象，具有方法拦截功能。

GroovyInterceptable接口是扩展了GroovyObject的标记接口，其实现对象上的所有方法调用，不管是否存在，都会调用其invokeMethod

Groovy支持对POJO和POGO进行元编程。对POJO，groovy维护了MetaClass的一个MetaClassRegistry，POGO有一个到其MetaClass的直接引用

多重继承中最经典的是菱形继承问题，无法确定所继承的功能到底来自哪个父类，所以c++又引入了复杂的虚拟继承机制

方法合成(method synthesis)h指，调用时动态地确定方法的行为。合成的方法可能直到调用时才会作为独立的方法存在。

继承用来扩展一个类的行为，而委托依赖锁包含或聚合的对象可以提供一个类的行为。is-a
若想用一个对象替代另一个，应该选择继承；若只是想简单地使用一个对象，应该选择委托。kind-of


groovy同时提供运行时和编译时元编程
编译时元编程是一种高级特性，用于某些特殊情况，主要是框架或工具的编写者使用
借助groovy，可以在编译时分析和修改程序的结构。为应用带来高度的可扩展性，同时支持添加新的横切特性。

倡导编码标准，会尽力确保团队遵循一致的编程实践。

要检查代码异味，需要遍历代码结构，分析类名、方法名、字段和参数名等信息。可以通过一个解析器实现，但编译器已经分析过代码，不如依赖编译器，尽量减少人为的工作
groovy编译器允许我们进入其编译阶段，一窥其所处理的AST(抽象语法树)。
AST树结构描述了程序中的表达式和语句，它是使用节点表示的。随着编译过程的进行，程序的AST会被变换，包括节点的插入、删除和重新排列。在编译过程中，可以随着
AST的演进对他进行检查，加以修改，以及命令编译器去标记告警或错误
要使用编译时元编程，必须理解和使用AST。groovyConsole工具打开源代码，选择Script菜单下的Inspect AST菜单。


生成器是内部的DSL，为处理某些特定类型的问题提供了方便。生成器提供的语法不会吧使用者仅仅绑定到底层的结构或实现上。也不会替换掉底层实现，
只是为处理底层实现提供了一种优雅的方式

单元测试对元编程至关重要。
可以及时发现并理解其原因。在经历重构之后，代码仍然可以执行的

测试必须满足FAIR条件，快速fast、自动化automated、隔离isolated、可重复repeatable
宁可听计算机说我们的代码很糟糕，也不愿意听同事这么说
隔离确保了一个测试不会遗留下可能会影响另一个测试的残余状态，从而可以让任何顺序运行测试，可以运行所有测试、单个测试或选定一些测试
测试一定要能运行任意多次，得到的是确定性的、可预测的结果。前后清理，每次保证干净一致

编写单元测试时，考虑编写3种类型的测试：正面测试、负面测试和异常测试。
正面测试可以确定代码的表现符合预期。
负面测试检查代码能否按预期方式处理前置条件失效、无效输入等问题。
异常测试可以帮助看代码是否会抛出正确的异常，以及表现是否符合预期。

代码越小，内聚性越高，与周边环境解耦。

必须将被侧代码从其所在的的应用中分离或解耦出来。
为了进行单元测试，必须将其代码分离到一个方法中
可以借助存根和模拟来实现
存根用于代替真正的对象。当被测方法调用存根时，它会根据设定好的预期响应简单地应答。
模拟对象做的事情更多，可以帮助确定被测代码按预期方式与其依赖或协作对象交互。可以记录代码中在该对象所代表的协作对象上进行的方法调用次序和次数。可以确保传递给方法调用的是正确的参数。
存根验证状态，模拟验证行为
在测试中使用模拟时，不仅验证状态，也验证代码与其依赖的交互行为

模拟用于代替协作者，只是简单地向调用它的代码做出预期响应，以便让测试工作。
想个办法，通过开关控制代码依赖模拟还是真正的对象
像java静态类型语言，可以用接口。

单元测试需要很大的自律，收益大于成本。动态类型语言提供了更大的灵活性，单元测试非常关键


领域特定语言(Domain-Specific Language,DSL)针对某一个特定类型的问题。语法聚焦于指定的领域或问题。
一门DSL会很小，很简单，有表现力，聚焦于一个问题区域或领域
DSL特点：上下文驱动，流程
上下文使一切变得更紧凑，如用with，减少了混乱，提升了实际效果
流畅，改进了代码的可读性，也使代码自然地流动(如for(i in 0..9/0.upto(9)/10.times/))
groovy为循环提供了流程性，

设计一门dsl时，要确定要设计的是那种类型dsl：外部还是内部
外部dsl定义了一门新语言，可以灵活地选择语法，之后是解析语言中的命令并执行动作。
内部dsl，也称作嵌入式dsl，同样定义了一门语言，但是语法受到现有语言的约束。

使用一门语言来设计dsl就像配两岁的孩子玩耍，当孩子发脾气时，不要和他争，得让着她点






















